      SUBROUTINE PCHFE(N,X,F,D,INCFD,SKIP,NE,XE,FE,IERR)
C***BEGIN PROLOGUE  PCHFE
C***DATE WRITTEN   811020   (YYMMDD)
C***REVISION DATE  811028   (YYMMDD)
C***CATEGORY NO.  E1A
C***KEYWORDS  HERMITE INTERPOLATION, PIECEWISE CUBIC EVALUATION,
C             CUBIC HERMITE EVALUATION
C***AUTHOR  FRITSCH,F.N.,LLNL
C             MATHEMATICS AND STATISTICS DIVISION
C             LAWRENCE LIVERMORE NATIONAL LABORATORY
C             P.O. BOX 808  (L-310)
C             LIVERMORE, CA  94550
C             FTS 532-4275
C***PURPOSE  EVALUATES A PIECEWISE CUBIC HERMITE FUNCTION AT AN ARRAY
C            OF POINTS.
C            MAY BE USED BY ITSELF FOR HERMITE INTERPOLATION, OR AS AN
C            EVALUATOR FOR PCHIM OR PCHIC.
C***DESCRIPTION
C
C  CALLING SEQUENCE:
C
C           CALL  PCHFE (N, X, F, D, INCFD, SKIP, NE, XE, FE, IERR)
C
      INTEGER  N, INCFD, NE, IERR
      REAL  X(N), F(INCFD,N), D(INCFD,N), XE(NE), FE(NE)
      LOGICAL  SKIP
C
C   PARAMETERS:
C
C     N -- (INPUT) NUMBER OF DATA POINTS.  (ERROR RETURN IF N.LT.2 .)
C
C     X -- (INPUT) REAL ARRAY OF INDEPENDENT VARIABLE VALUES.  THE
C           ELEMENTS OF X MUST BE STRICTLY INCREASING:
C                X(I-1) .LT. X(I),  I = 2(1)N.
C           (ERROR RETURN IF NOT.)
C
C     F -- (INPUT) REAL ARRAY OF FUNCTION VALUES.  F(1+(I-1)*INCFD) IS
C           THE VALUE CORRESPONDING TO X(I).
C
C     D -- (INPUT) REAL ARRAY OF DERIVATIVE VALUES.  D(1+(I-1)*INCFD) IS
C           THE VALUE CORRESPONDING TO X(I).
C
C     INCFD -- (INPUT) INCREMENT BETWEEN SUCCESSIVE VALUES IN F AND D.
C           (ERROR RETURN IF  INCFD.LT.1 .)
C
C     SKIP -- (INPUT/OUTPUT) LOGICAL VARIABLE WHICH SHOULD BE SET TO
C           .TRUE. IF THE USER WISHES TO SKIP CHECKS FOR VALIDITY OF
C           PRECEDING PARAMETERS, OR TO .FALSE. OTHERWISE.
C           THIS WILL SAVE TIME IN CASE THESE CHECKS HAVE ALREADY
C           BEEN PERFORMED (SAY, IN PCHIM OR PCHIC).
C           SKIP WILL BE SET TO .TRUE. ON NORMAL RETURN.
C
C     NE -- (INPUT) NUMBER OF EVALUATION POINTS.  (ERROR RETURN IF
C           NE.LT.1 .)
C
C     XE -- (INPUT) REAL ARRAY OF POINTS AT WHICH THE FUNCTION IS TO BE
C           EVALUATED.
C          NOTES:
C           1. THE EVALUATION WILL BE MOST EFFICIENT IF THE ELEMENTS
C              OF XE ARE INCREASING RELATIVE TO X;
C              THAT IS,   XE(J) .GE. X(I)
C              IMPLIES    XE(K) .GE. X(I),  ALL K.GE.J .
C           2. IF ANY OF THE XE ARE OUTSIDE THE INTERVAL [X(1),X(N)],
C              VALUES ARE EXTRAPOLATED FROM THE NEAREST EXTREME CUBIC,
C              AND A WARNING ERROR IS RETURNED.
C
C     FE -- (OUTPUT) REAL ARRAY OF VALUES OF THE CUBIC HERMITE FUNCTION
C           DEFINED BY  N, X, F, D  AT THE POINTS  XE.
C
C     IERR -- (OUTPUT) ERROR FLAG.
C           NORMAL RETURN:
C              IERR = 0  (NO ERRORS).
C           WARNING ERROR:
C              IERR.GT.0  MEANS THAT EXTRAPOLATION WAS PERFORMED AT
C                 IERR POINTS.
C           "RECOVERABLE" ERRORS:
C              IERR = -1  IF N.LT.2 .
C              IERR = -2  IF INCFD.LT.1 .
C              IERR = -3  IF THE X-ARRAY IS NOT STRICTLY INCREASING.
C              IERR = -4  IF NE.LT.1 .
C             (THE FE-ARRAY HAS NOT BEEN CHANGED IN ANY OF THESE CASES.)
C               NOTE:  THE ABOVE ERRORS ARE CHECKED IN THE ORDER LISTED,
C                   AND FOLLOWING ARGUMENTS HAVE **NOT** BEEN VALIDATED.
C              IERR = -5  IF AN ERROR HAS OCCURRED IN THE LOWER-LEVEL
C                         ROUTINE CHFEV.  NB: THIS SHOULD NEVER HAPPEN.
C                         NOTIFY THE AUTHOR **IMMEDIATELY** IF IT DOES.
C
C-----------------------------------------------------------------------
C***REFERENCES  (NONE)
C***ROUTINES CALLED  CHFEV
C***END PROLOGUE  PCHFE
C-----------------------------------------------------------------------
C
C  PROGRAMMING NOTES.
C
C     1. TO PRODUCE A DOUBLE PRECISION VERSION, SIMPLY:
C        A. CHANGE PCHFE TO DPCHFE, AND CHFEV TO DCHFEV, WHEREVER THEY
C           OCCUR,
C        B. CHANGE THE REAL DECLARATION TO DOUBLE PRECISION,
C
C     2. MOST OF THE CODING BETWEEN THE CALL TO CHFEV AND THE END OF
C        THE IR-LOOP COULD BE ELIMINATED IF IT WERE PERMISSIBLE TO
C        ASSUME THAT XE IS ORDERED RELATIVE TO X.
C
C     3. CHFEV DOES NOT ASSUME THAT X1 IS LESS THAN X2.  THUS, IT WOULD
C        BE POSSIBLE TO WRITE A VERSION OF PCHFE THAT ASSUMES A STRICT-
C        LY DECREASING X-ARRAY BY SIMPLY RUNNING THE IR-LOOP BACKWARDS
C        (AND REVERSING THE ORDER OF APPROPRIATE TESTS).
C
C     4. THE PRESENT CODE HAS A MINOR BUG, WHICH I HAVE DECIDED IS NOT
C        WORTH THE EFFORT THAT WOULD BE REQUIRED TO FIX IT.
C        IF XE CONTAINS POINTS IN [X(N-1),X(N)], FOLLOWED BY POINTS .LT.
C        X(N-1), FOLLOWED BY POINTS .GT.X(N), THE EXTRAPOLATION POINTS
C        WILL BE COUNTED (AT LEAST) TWICE IN THE TOTAL RETURNED IN IERR.
C
C-----------------------------------------------------------------------
C
C  LOCAL DECLARATIONS.
C
      INTEGER  I, IERC, IR, J, JFIRST, NEXT(2), NJ
C
C  VALIDITY-CHECK ARGUMENTS.
C
C***FIRST EXECUTABLE STATEMENT  PCHFE
      IF (SKIP)  GO TO 5
C
      IF ( N.LT.2 )  GO TO 5001
      IF ( INCFD.LT.1 )  GO TO 5002
      DO 1  I = 2, N
         IF ( X(I).LE.X(I-1) )  GO TO 5003
    1 CONTINUE
C
C  FUNCTION DEFINITION IS OK, GO ON.
C
    5 CONTINUE
      IF ( NE.LT.1 )  GO TO 5004
      IERR = 0
      SKIP = .TRUE.
C
C  LOOP OVER INTERVALS.        (   INTERVAL INDEX IS  IL = IR-1  . )
C                              ( INTERVAL IS X(IL).LE.X.LT.X(IR) . )
      JFIRST = 1
      IR = 2
   10 CONTINUE
C
C     SKIP OUT OF LOOP IF HAVE PROCESSED ALL EVALUATION POINTS.
C
         IF (JFIRST .GT. NE)  GO TO 5000
C
C     LOCATE ALL POINTS IN INTERVAL.
C
         DO 20  J = JFIRST, NE
            IF (XE(J) .GE. X(IR))  GO TO 30
   20    CONTINUE
         J = NE + 1
         GO TO 40
C
C     HAVE LOCATED FIRST POINT BEYOND INTERVAL.
C
   30    CONTINUE
         IF (IR .EQ. N)  J = NE + 1
C
   40    CONTINUE
         NJ = J - JFIRST
C
C     SKIP EVALUATION IF NO POINTS IN INTERVAL.
C
         IF (NJ .EQ. 0)  GO TO 50
C
C     EVALUATE CUBIC AT XE(I),  I = JFIRST (1) J-1 .
C
C       ----------------------------------------------------------------
        CALL CHFEV (X(IR-1),X(IR), F(1,IR-1),F(1,IR), D(1,IR-1),D(1,IR),
     *              NJ, XE(JFIRST), FE(JFIRST), NEXT, IERC)
C       ----------------------------------------------------------------
         IF (IERC .LT. 0)  GO TO 5005
C
         IF (NEXT(2) .EQ. 0)  GO TO 42
C        IF (NEXT(2) .GT. 0)  THEN
C           IN THE CURRENT SET OF XE-POINTS, THERE ARE NEXT(2) TO THE
C           RIGHT OF X(IR).
C
            IF (IR .LT. N)  GO TO 41
C           IF (IR .EQ. N)  THEN
C              THESE ARE ACTUALLY EXTRAPOLATION POINTS.
               IERR = IERR + NEXT(2)
               GO TO 42
   41       CONTINUE
C           ELSE
C              WE SHOULD NEVER HAVE GOTTEN HERE.
               GO TO 5005
C           ENDIF
C        ENDIF
   42    CONTINUE
C
         IF (NEXT(1) .EQ. 0)  GO TO 49
C        IF (NEXT(1) .GT. 0)  THEN
C           IN THE CURRENT SET OF XE-POINTS, THERE ARE NEXT(1) TO THE
C           LEFT OF X(IR-1).
C
            IF (IR .GT. 2)  GO TO 43
C           IF (IR .EQ. 2)  THEN
C              THESE ARE ACTUALLY EXTRAPOLATION POINTS.
               IERR = IERR + NEXT(1)
               GO TO 49
   43       CONTINUE
C           ELSE
C              XE IS NOT ORDERED RELATIVE TO X, SO MUST ADJUST
C              EVALUATION INTERVAL.
C
C              FIRST, LOCATE FIRST POINT TO LEFT OF X(IR-1).
               DO 44  I = JFIRST, J-1
                  IF (XE(I) .LT. X(IR-1))  GO TO 45
   44          CONTINUE
C              NOTE:  CANNOT DROP THROUGH HERE UNLESS THERE IS AN ERROR
C                     IN CHFEV.
               GO TO 5005
C
   45          CONTINUE
C              RESET J.  (THIS WILL BE THE NEW JFIRST.)
               J = I
C
C              NOW FIND OUT HOW FAR TO BACK UP IN THE X-ARRAY.
               DO 46  I = 1, IR-1
                  IF (XE(J) .LT. X(I)) GO TO 47
   46          CONTINUE
C              NB:  CAN NEVER DROP THROUGH HERE, SINCE XE(J).LT.X(IR-1).
C
   47          CONTINUE
C              AT THIS POINT, EITHER  XE(J) .LT. X(1)
C                 OR      X(I-1) .LE. XE(J) .LT. X(I) .
C              RESET IR, RECOGNIZING THAT IT WILL BE INCREMENTED BEFORE
C              CYCLING.
               IR = MAX0(1, I-1)
C           ENDIF
C        ENDIF
   49    CONTINUE
C
         JFIRST = J
C
C     END OF IR-LOOP.
C
   50 CONTINUE
      IR = IR + 1
      IF (IR .LE. N)  GO TO 10
C
C  NORMAL RETURN.
C
 5000 CONTINUE
      RETURN
C
C  ERROR RETURNS.
C
 5001 CONTINUE
C     N.LT.2 RETURN.
      IERR = -1
      CALL XERROR ('PCHFE -- NUMBER OF DATA POINTS LESS THAN TWO',
     * 44, IERR, 1)
      RETURN
C
 5002 CONTINUE
C     INCFD.LT.1 RETURN.
      IERR = -2
      CALL XERROR ('PCHFE -- INCREMENT LESS THAN ONE', 32, IERR, 1)
      RETURN
C
 5003 CONTINUE
C     X-ARRAY NOT STRICTLY INCREASING.
      IERR = -3
      CALL XERROR ('PCHFE -- X-ARRAY NOT STRICTLY INCREASING',40,IERR,1)
      RETURN
C
 5004 CONTINUE
C     NE.LT.1 RETURN.
      IERR = -4
      CALL XERROR ('PCHFE -- NUMBER OF EVALUATION POINTS LESS THAN ONE',
     *  50, IERR, 1)
      RETURN
C
 5005 CONTINUE
C     ERROR RETURN FROM CHFEV.
C   *** THIS CASE SHOULD NEVER OCCUR ***
      IERR = -5
      CALL XERROR('PCHFE -- ERROR RETURN FROM CHFEV -- FATAL',41,IERR,2)
      RETURN
C------------- LAST LINE OF PCHFE FOLLOWS ------------------------------
      END
