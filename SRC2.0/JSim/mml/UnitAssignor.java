/*NSRCOPYRIGHT
	Copyright (C) 1999-2011 University of Washington
	Developed by the National Simulation Resource
	Department of Bioengineering,  Box 355061
	University of Washington, Seattle, WA 98195-5061.
	Dr. J. B. Bassingthwaighte, Director
END_NSRCOPYRIGHT*/

// assign units to flat model vars with null unit

package JSim.mml; 

import JSim.util.*;
import JSim.expr.*;
import java.util.ArrayList;

public class UnitAssignor implements DiagInfo {
	private VarSet vars; // unassigned unit vars
	private boolean working; // anything done during loop?
	private DiagInfo wdiag; // diag source for single process() call
	private boolean nullToScalar; // convert null units to scalar?

	// constructor
	public UnitAssignor(MathSys math) throws Xcept {
	    // tabulate null unit RealNVars
	    vars = new VarSet(math);
	    for (int i=0; i<math.nVar(); i++) {
		Var v = math.var(i);
		if (! (v instanceof RealNVar)) continue;
		if (v.unit() != null) continue;
		vars.add(v);
	    }
	    if (vars.size() == 0) return; // nothing to do

	    // processConstantEqns(math);
	    nullToScalar = false;
	    process(math);
	    nullToScalar = true;
	    process(math);

/*  THIS BREAKS SOME MODELS,  so leave these vars unitless
	    // assign remains vars dimensionless
 	    for (int i=0; i<math.nVar(); i++) {
		Var v = math.var(i);
		if (! (v instanceof RealNVar)) continue;
		if (v.unit() != null) continue;
		if (v.isDeriv()) continue;
		assign(v, Unit.scalar(), this);
	    }
*/
	}

	// process v=constant unit equations
	//   eqns generated by e.g. a = 3 cm;
	private void processConstantEqns(MathSys math) throws Xcept {
	    for (int i=0; i<math.eqn.size(); i++) {
		Eqn eqn = math.eqn.eqn(i);
		if (! (eqn.lhs instanceof Var)) continue;
		Unit u = eqn.rhs.unit();
		if (u == null) continue;
		Var v = (Var) eqn.lhs;
		if (v.unit() != null) continue;
	    	Util.verbose("\tAssign " + v + " unit=" + u.pubName()
		    + " via " + eqn);
		v.setUnit(u);
	    }
	}

	// process all eqns & events till no more assignments
	private void process(MathSys math) throws Xcept {
	    working = true;
	    while (working) {
		working = false;
	    	for (int i=0; i<math.eqn.size(); i++) {
		    Eqn eqn = math.eqn.eqn(i);
		    process(eqn.sdom.expr, eqn);
		    process(eqn.lhs.eq(eqn.rhs), eqn);
		    if (vars.size() == 0) break;
	    	}
	    	for (int i=0; i<math.events.size(); i++) {
		    Event event = math.events.event(i);
	            process(event.trigger(), event);
		    for (int j=0; j<event.nactions(); j++) {
		    	Expr e = event.v(j).eq(event.vexpr(j));
		    	process(e, event);
		    }
		    if (vars.size() == 0) break;
		}
	    }
	}	   

	// completely process single expression
	private void process(Expr base, DiagInfo diag) throws Xcept {
	    wdiag = diag;
	    Var.List vs = nullUnitVars(base);
	    if (vs.size() == 0) return; // skip if no unitless vars
	    debug("base=" + base);
	    process(base);
	}

	// recursively process expression
	private void process(Expr base) throws Xcept {
	    if (wdiag == null) return; // terminated in assign()
	    if (base instanceof IExpr)  
	    	process((IExpr) base);
	    if (base instanceof UnitCast) {
	    	UnitCast cast = (UnitCast) base;
	    	Expr one = new RealConst(1, Unit.scalar());
	    	processEqn(cast.expr(), one, cast);
	    }
	}
		
	// process IExpr
	private void process(IExpr base) throws Xcept {
	    debug("  process " + base);
	    for (int i=0; i<base.nargs(); i++)
		process(base.arg(i));

	    switch (base.op()) {
	    case IExpr.LN:  // transcendental funcs req dimless arg
	    case IExpr.LOG:
	    case IExpr.SIN:
	    case IExpr.COS:
	    case IExpr.TAN:
	    case IExpr.EXP:
	    case IExpr.ASIN:
	    case IExpr.ACOS:
	    case IExpr.FLOOR: // otherwise floor(.5 kg) != floor(500 g)
	    case IExpr.CEIL:
	    case IExpr.ROUND:
		processDimless(base.arg(0), base);
		break;
	    case IExpr.ADD: // these binops req
	    case IExpr.SUB:
	    case IExpr.ATAN:
	    case IExpr.REM:
	    case IExpr.EQ:
	    case IExpr.NE:
	    case IExpr.LT:
	    case IExpr.LE:
	    case IExpr.GT:
	    case IExpr.GE:
	    case IExpr.APPROX:
	    	if (base.arg(0).dataType() == Expr.REAL) 
		    processEqn(base.arg(0), base.arg(1), base);
		break;
	    case IExpr.POW:
		// needs work
		break;
	    }
	}
	
	// given expression should be dimensionless
	private void processDimless(Expr expr, DiagInfo diag) throws Xcept {
	    debug("    processDimless " + expr);
	    Expr one = new RealConst(1, Unit.scalar());
	    processEqn(expr, one, diag);
	}

	// arguments should have same units
	private void processEqn(Expr lhs, Expr rhs, DiagInfo diag) 
	throws Xcept {
	    Expr expr = lhs.eq(rhs);
	    Var.List vs = nullUnitVars(expr);
	    debug("      processEqn" + vs + " " + expr);
	    if (vs.size() != 1) return; 
	    Var v = vs.var(0);
	    try {
		Expr vexpr = Algebra.solveUnit(v, lhs, rhs);
		debug("       orig vexpr=" + vexpr);
		vexpr = vexpr.unitCorrect();
		debug("       corrected vexpr=" + vexpr);
		Unit u = vexpr.unit();
		if (u == null) {
		    if (! nullToScalar) return;
		    u = Unit.scalar();
		}
		assign(v, u, diag);
	    } catch (Xcept e) {
		// debug("        " + e);
	    }
	}

	// assign unit to a all related deriv vars
	private void assign(Var v, Unit u, DiagInfo diag) 
	throws Xcept {

	    // reset v/u to zeroDeriv
	    while (v.isDeriv()) {
		Domain x = v.derivDomain();
		v = v.unDeriv();
	 	if (x.unit() != null)
		    u = u.mult(x.unit());
	    }
	    assign1(v, u, diag);
	    wdiag = null; // terminate process()
	}

	// assign units to var and deriv subvars
	private void assign1(Var v, Unit u, DiagInfo diag)
	throws Xcept {
	    if (Unit.compatible(u, Unit.scalar()))
		u = Unit.scalar();
	    u = PrettyUnit.unit(u);
	    Util.verbose("\tAssign " + v + " unit=" + u.pubName()
		+ " via " + diag);
	    v.setUnit(u);
	    vars.sub(v);
	    working = true;

	    // assign subvars
	    for (int i=0; i<v.ndim(); i++) {
		Domain x = v.domain(i);
		try {
		    Var vx = v.deriv(x, false);
		    if (vx == null) continue;
		    Unit ux = (x.unit() == null) ? u : u.div(x.unit());
		    assign1(vx, ux, diag);
		} catch (Xcept e) {
		    // nothing to do
		}
	    }		
	}  

	// find null-unit vars in Expr
	private Var.List nullUnitVars(Expr expr) throws Xcept {
	    Comp.List list = new Comp.List(8);
	    expr.addNamedExpr(list);
	    Var.List vars = new Var.List(list.size());
	    for (int i=0; i<list.size(); i++) {
		if (! (list.comp(i) instanceof RealNVar)) continue;
		RealNVar v = (RealNVar) list.comp(i);
		if (v.unit() != null) continue;
		vars.add(v);
	    }
	    return vars;
	}

	// simple query
	public String diagInfo() {
	    return "Model unit corrector";
	}

	// debug message
	private void debug(String s) {
	    // System.err.println("UnitAssignor: " + s);
	}
}	
	
