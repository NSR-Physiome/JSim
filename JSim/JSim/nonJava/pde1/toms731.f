C#######################################################################
C
C SPMDIF : moving-grid interface routines
C
C#######################################################################
C
C-----------------------------------------------------------------------
C
C Moving grid discretization module SPMDIF
C ----------------------------------------
C This module discretizes systems of partial differential equations
C in one space variable on a moving grid. The class of equations that
C can be handled is given by
C
C   NPDE                   k                      -m  m
C   sum  C   (x,t, u, u ) u  + Q (x,t, u, u ) =  x  (x  R (x,t, u, u ))
C   k=1   j,k      -  -x   t    j      -  -x             j      -  -x  x
C
C where            1         NPDE T
C           u = ( u , ... , u    )   ,  j = 1,... , NPDE,
C           -
C      k
C and u  is the partial derivative wrt time of the k-th component of u.
C      t
C
C The functions C, Q, and R are assumed to be continuous w.r.t. the
C space variable.
C
C The independent variables x and t satisfy  x  < x < x   with x  and x
C                                             L        R        L      R
C fixed and  t > t .
C                 0
C The boundary conditions have the form
C
C   BETA(x,t).R(x,t,u,u ) = GAMMA(x,t,u,u )  at x = x , x  ,
C                   - -x              - -x           L   R
C
C where not all of the functions BETA and GAMMA are set to zero.
C
C The initial conditions are given by
C                0
C   u (x,t )  = u (x)  for x  <= x <= x .
C   -     0     -           L          R
C The discretization method for the PDE in Lagrangian formulation
C used by this module is based on a lumped Galerkin / Petrov-Galerkin
C method and evaluates the PDE functions in a point between
C the (moving) grid points.
C
C References:
C   Fixed-grid spatial discretization
C            Skeel R.D. and Berzins M.
C            A Method for the Spatial Discretisation of Parabolic
C            Equations in one Space Variable.
C            Leeds Report no 217,
C            Dept. of Computer Studies, The University.
C   Grid movement
C            Verwer J.G., Blom J.G., Furzeland R.M. and Zegeling P.A.
C            A Moving-Grid Method for One-Dimensional PDEs based on
C            the Method of Lines.
C            Report NM-R8818,
C            Centre for Mathematics and Computer Science, Amsterdam.
C   Interface
C            Blom J.G. and Zegeling P.A.
C            A Moving-Grid Interface for Systems of One-Dimensional
C            Time-Dependent Partial Differential Equations.
C            Report NM-R8904,
C            Centre for Mathematics and Computer Science, Amsterdam.
C            (submitted to ACM TOMS)
C
C----------------------------------------------------------------------
C
C How to use this module
C ----------------------
C 1.  Set NPDE = # PDEs to be solved.
C     Set NPTS = # mesh points to be used.
C                (NC=NPTS-2 is # internal points)
C     Set M for space coordinate type
C         = 0 for Cartesian,  = 1 for cylindrical, = 2 for spherical.
C     Specify a workspace of size at least  (NPDE+1)*NPTS+(6+NPDE)*NPDE
C     for use by the routine SKMRES which defines the DAE system being
C     solved by the integrator.
C
C     Call the initialization routine SETSKM, see the documentation at
C     the head of this routine for the precise details of the call.
C
C     Set TS and TOUT for start and end integration times.
C     Initialize data as required for time integration,
C                - see documentation of DAE solver.
C     Call the DAE solver with as residual routine SKMRES or an
C     enveloping routine to satisfy the header requirements.
C
C 2.  Provide a set of routines which describe the precise form of the
C     PDEs to be solved. Three routines must be provided and the names
C     of these routines are fixed. These routines are:
C        SPDEF   forms the functions C, Q and R of the PDE in a
C                given x-point.
C        BNDR    forms the functions BETA and GAMMA associated with the
C                boundary conditions for the PDE.
C        UINIT   supplies the initial values of the PDE part.
C                An initial uniform grid is generated by SETSKM and
C                provided in Y(NPDE+1,I), I=1,NPTS. If required, a user
C                can redefine the mesh in a nonuniform way.
C     The headers of these routines are:
C
C      SUBROUTINE SPDEF (ithrndx,ikilflg,
C     *                  T, X, NPDE, U, DUDX, C, Q, R, IRES)
C SEE DDASSL DOCUMENTATION FOR ithrndx,ikilflg
C      INTEGER NPDE, IRES
C      DOUBLE PRECISION T, X
C      DOUBLE PRECISION U(NPDE), DUDX(NPDE), C(NPDE,NPDE), Q(NPDE),
C     +     R(NPDE)
C
C      SUBROUTINE BNDR (ithrndx,ikilflg,
C     *                 T, BETA, GAMMA, U, DUDX, NPDE, LEFT, IRES)
C SEE DDASSL DOCUMENTATION FOR ithrndx,ikilflg
C      INTEGER NPDE, IRES
C      LOGICAL LEFT
C      DOUBLE PRECISION T
C      DOUBLE PRECISION BETA(NPDE), GAMMA(NPDE), U(NPDE), DUDX(NPDE)
C
C      SUBROUTINE UINIT (NPDE, NPTS, Y)
C      INTEGER NPDE, NPTS
C      DOUBLE PRECISION Y(NPDE+1,NPTS)
C
C
C Example problem
C ---------------
C The easiest way to describe how the problem description routines
C should be written is by a simple example. Consider the following
C problem from electrodynamics
C    u  = eps.p.u   - g(u-v)
C     t          xx
C and                             (so m = 0 and NPDE = 2)
C    v  =     p.v   + g(u-v)
C     t          xx
C with
C    g(z) = exp(eta.z/3) - exp(-2.eta.z/3) ,
C    0 <= x <= 1  and  0 <= t <= 4;
C    eps = 0.143, p = 0.1743, and eta = 17.19.
C
C The left boundary condition (LEFT = .TRUE.) is given by
C    u  = 0  and  v = 0   at x = 0,
C     x
C the right boundary condition (LEFT = .FALSE.) is
C    u = 0  and  v  = 0   at x = 1,
C                 x
C and the initial conditions are
C    u = 1  and  v = 0  at t = 0.
C
C The routines UINIT, SPDEF and BNDR are listed below.
C The component u of the PDE at the i-th grid point is held as Y(1,i)
C in the package, the component v as Y(2,i); the i-th grid point
C itself is stored in Y(3,i).
C
C
C
C     SUBROUTINE UINIT (ithrndx,ikilflg,
C    *                  NPDE, NPTS, Y)
C SEE DDASSL DOCUMENTATION FOR ithrndx,ikilflg
C
C Routine for PDE initial values.
C Entry:
C   Y(NPDE+1,i) = x_i; uniform mesh, generated by package
C Exit:
C   Y(NPDE+1,i) = x_i; mesh, optionally changed by user
C   Y(     k,i) = u_k(x_i,t0); initial value of k-th component
C                                  i = 1,.., NPTS
C
C     INTEGER NPDE, NPTS
C     DOUBLE PRECISION Y(NPDE+1,NPTS)
C
C     INTEGER I
C
C     DO 10 I = 1, NPTS
C        Y(1,I) = 1.0
C        Y(2,I) = 0.0
C  10 CONTINUE
C
C     RETURN
C     END
C
C
C
C     SUBROUTINE SPDEF (ithrndx,ikilflg,
C    *                  T, X, NPDE, U, DUDX, C, Q, R, IRES)
C SEE DDASSL DOCUMENTATION FOR ithrndx,ikilflg
C
C Routine to describe the body of the PDE system.
C The PDE is written as
C   NPDE               k                    -m   m
C   sum C  (x,t,u,u ) u  + Q (x,t,u,u )  = x   (x  R (x,t,u,u ) ) .
C   k=1  jk        x   t    j        x              j        x   x
C The functions C, Q and R must be defined in this routine.
C
C     INTEGER NPDE, IRES
C     DOUBLE PRECISION T, X
C     DOUBLE PRECISION U(NPDE), DUDX(NPDE), C(NPDE,NPDE), Q(NPDE),
C    +     R(NPDE)
C
C     INTEGER J, K
C     DOUBLE PRECISION EPS, ETA, GZ, P, Z
C     DATA EPS /0.143/, ETA /17.19/, P /0.1743/
C
C     DO 10 K = 1, NPDE
C        DO 20 J = 1, NPDE
C           C(J,K) = 0.0
C  20    CONTINUE
C        C(K,K) = 1.0
C  10 CONTINUE
C
C     Z  = U(1) - U(2)
C     GZ = EXP(ETA*Z/3) - EXP(-2*ETA*Z/3)
C     Q(1) =  GZ
C     Q(2) = -GZ
C
C     R(1) = EPS*P * DUDX(1)
C     R(2) =     P * DUDX(2)
C
C     RETURN
C     END
C
C
C
C     SUBROUTINE BNDR (ithrndx,ikilflg,
C    *                 T, BETA, GAMMA, U, DUDX, NPDE, LEFT, IRES)
C SEE DDASSL DOCUMENTATION FOR ithrndx,ikilflg
C
C Boundary conditions routine
C The boundary conditions are written as
C   BETA (x,t) R (x,t,u,u ) = GAMMA (x,t,u,u )
C       j       j        x         j        x
C The functions BETA and GAMMA should be defined in this routine.
C
C     INTEGER NPDE, IRES
C     LOGICAL LEFT
C     DOUBLE PRECISION T
C     DOUBLE PRECISION BETA(NPDE), GAMMA(NPDE), U(NPDE), DUDX(NPDE)
C
C     IF (LEFT) THEN
C        BETA (1) = 1.0
C        GAMMA(1) = 0.0
C        BETA (2) = 0.0
C        GAMMA(2) = U(2)
C     ELSE
C        BETA (1) = 0.0
C        GAMMA(1) = U(1) - 1.0
C        BETA (2) = 1.0
C        GAMMA(2) = 0.0
C     ENDIF
C
C     RETURN
C     END
C
      SUBROUTINE SETSKM (ithrndx,ikilflg,
     +                   NEQN, NPDE, NPTS, XL, XR, TAU, KAPPA, ALPHA,
     +                   Y, RWK, NRWK, M, TS, IBAND, IRES,
     +                   dpx,ilx,ix,icx)
      double precision dpx(4), RTAU, RKAPPA, ALFA, SRELPR
      integer ilx, icx
      logical SING
      integer ix(6), NPDE1, NC,MM, NERR, NNNPDE, NNNPTS
      character*6 PDCODE
      external YINIT

C
C-----------------------------------------------------------------------
C Purpose:
C -------
C Initializing routine for moving-grid spatial discretization.
C
C Parameters:
C ----------
      INTEGER NEQN, NPDE, NPTS, NRWK, M, IBAND, IRES
      DOUBLE PRECISION XL, XR, TAU, KAPPA, ALPHA, TS
      DOUBLE PRECISION Y(*), RWK(NRWK)
C
C NEQN  Exit: the size of the DAE system generated when the PDE +
C       the grid equations are discretized. This value is (NPDE+1).NPTS.
C NPDE  Entry: the number of PDEs.
C NPTS  Entry: the number of spatial mesh points, including the
C       boundary points.
C XL    Entry: left boundary point.
C XR    Entry: right boundary point.
C TAU   Entry: time-smoothing parameter.
C       If the initial grid satisfies the grid equation with TAU=0 at
C       TS=0, TAU can be chosen equal to zero. If this is not the case
C       and if the initial grid has to be adapted, or if time-smoothing
C       is desired a typical value of TAU = 1E-3, but TAU should be
C       related to the time scale of the problem.
C KAPPA Entry: spatial smoothing parameter (DOUBLE PRECISION).
C       KAPPA = 2.0 was found to be satisfying for all problems tested.
C       For less spatial smoothing KAPPA = 1.0 will suffice.
C ALPHA Entry: monitor regularizing parameter.
C       ALPHA = 0.01 is recommended (for a well-scaled system of PDEs)
C Y     Exit: array of length >= (NPDE+1).NPTS that contains the initial
C       (uniformly spaced) grid and the corresponding initial PDE
C       solution values. This array must be passed across as a one-
C       dimensional array of length NEQN to the DAE solver. This
C       array is ordered as
C          PDE comp.  : Y((NPDE+1)*l + j) l=0,...,NPTS-1,
C                                         j=1,...,NPDE
C          grid points: Y((NPDE+1)*(l+1)) l=0,...,NPTS-1.
C RWK   workspace of length NRWK for the residual routine SKMRES which
C       actually performs the semi-discretization of the PDEs and
C       defines the grid equations.
C NRWK  Entry: dimension of workspace RWK.
C       NRWK must be >= (NPDE+1).NPTS + (6+NPDE).NPDE.
C M     Entry: integer >= 0 which determines the coordinate system used.
C          0: Cartesian coordinates,
C          1: cylindrical polar coordinates,
C          2: spherical polar coordinates.
C TS    Entry: the time at which the integration starts.
C IBAND Exit: an upper bound on the half bandwidth of the Jacobian
C       matrix when this module is used. (If the DAE solver is called
C       with banded matrix routines this parameter should be
C       supplied to MATSET (SPRINT) or to DASSL (IWORK(1) and IWORK(2)).
C IRES  Exit: this parameter is set to -1 if an error is found by
C       this routine.
C
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
C From here the comments are only meant as aid and assistance to
C understand the program.
C
C Four parameters are passed across from here in
C      COMMON /SPSKM/  NPDE1, NC, M, SING
C
C NPDE1 = NPDE+1   the number of PDEs + 1 (for the grid equation).
C NC    = NPTS-2   the number of internal mesh points.
C M     = M_user   = 0,1,2, if resp., Cartesian, cylindrical or
C                           spherical polar coordinates in use.
C SING  = .TRUE.   if PDE has a polar singularity.
C
C A common block filled with method parameters is initialized
C in this routine
C      COMMON /METPAR/ RTAU, RKAPPA, ALFA
C
C RTAU   time-smoothing parameter grid equation (= TAU)
C RKAPPA spatial smoothing parameter grid equation (= KAPPA)
C ALFA   monitor constant (= ALPHA)
C
C A common block filled with machine constants is also initialized
C in this routine
C      COMMON /MACH/ NERR, SRELPR
C
C NERR   logical unit number of error unit
C SRELPR machine eps as determined by MACHAR
C
C
C Detailed description of workspace:
C ---------------------------------
C Size:  NRWK must be >=  (NPDE+1)*NPTS + (6+NPDE)*NPDE
C
C RWK(  1:.+(NPDE+1)*NPTS) G(NPDE+1,0:NC+1), part of residual not
C                          dependent on time-derivative.
C RWK(IW1:.+ NPDE)         UKSI(NPDE), solution values at evaluat. point
C RWK(IW2:.+ NPDE)         UXKSI(NPDE), space derivs. at evaluat. point
C RWK(IW3:.+ NPDE)         BETA(NPDE), boundary function BETA
C RWK(IW4:.+ NPDE)         GAMMA(NPDE), boundary function GAMMA
C RWK(IW5:.+ NPDE)         RC(NPDE), flux at evaluation point
C RWK(IW6:.+ NPDE)         QC(NPDE), source term at evaluation point
C RWK(IW7:.+ NPDE*NPDE)    CC(NPDE,NPDE), udot factor at evaluat. point
C
C-----------------------------------------------------------------------
C
cQ    CHARACTER*6 PDCODE
cQ    COMMON /DISCHK/ PDCODE
C
cQ    INTEGER NPDE1, NC, MM
cQ    LOGICAL SING
cQ    COMMON /SPSKM/ NPDE1, NC, MM, SING
C
cQ    DOUBLE PRECISION RTAU, RKAPPA, ALFA
cQ    COMMON /METPAR/ RTAU, RKAPPA, ALFA
C
cQ    INTEGER NERR
cQ    DOUBLE PRECISION SRELPR
cQ    COMMON /MACHAA/ NERR
cQ    COMMON /MACHBB/ SRELPR
C
cQ    INTEGER NNNPDE, NNNPTS
cQ    COMMON /forRESID/ NNNPDE, NNNPTS
C
cQ    SAVE   /DISCHK/
cQ    SAVE   /SPSKM/
cQ    SAVE   /METPAR/
cQ    SAVE   /MACHAA/
cQ    SAVE   /MACHBB/
cQ    SAVE   /forRESID/
C
      EXTERNAL MACHAR
C
C-----------------------------------------------------------------------
C
      INTEGER IW1, IW2, IW3, IW4, IW5, IW6, IW7, IWE
      INTEGER IBETA, IT,IRND, NGRD, MACHEP, NEGEP, IEXP, MINEXP,
     +        MAXEXP
      DOUBLE PRECISION EPS, EPSNEG, XMIN, XMAX
      CALL FETCHCOMMON(dpx,RTAU,RKAPPA,ALFA,SRELPR,
     +                       ilx, SING,
     +                       ix, NPDE1,NC,M,NERR,NNNPDE,NNNPTS,
     +                       icx, PDCODE)

      nnnpde = npde
      nnnpts = npts

      NPDE1 = NPDE+1
      NC = NPTS-2
      MM = M
      SING = M .GE. 1 .AND. ABS(XL) .LE. SRELPR*(XR-XL)
cQ    write(*,*) 'sing,srelpr ',sing,srelpr

      RTAU   = TAU
      RKAPPA = KAPPA
      ALFA   = ALPHA

      NERR   = 8
      CALL MACHAR (IBETA, IT,IRND, NGRD, MACHEP, NEGEP, IEXP, MINEXP,
     +             MAXEXP, EPS, EPSNEG, XMIN, XMAX)
      SRELPR = MAX (EPS, EPSNEG)
cQ    write(*,*) 'srelpr ',srelpr

C Fill IBAND; ML = MU=2*NPDE1
      IBAND = 2*NPDE1

      NEQN = NPDE1*NPTS

      IW1 =   1 + NEQN
      IW2 = IW1 + NPDE
      IW3 = IW2 + NPDE
      IW4 = IW3 + NPDE
      IW5 = IW4 + NPDE
      IW6 = IW5 + NPDE
      IW7 = IW6 + NPDE
      IWE = IW7 + NPDE*NPDE - 1
      IF (IWE .GT. NRWK) THEN
c         WRITE(NERR,'(38H SETSKM - ERROR REAL WORKSPACE OF SIZE, I10,
c     +                28H, IS SMALLER THAN REQUIRED :, I10)') NRWK, IWE
         IRES = -1
      ENDIF
      IF (M .LT. 0) THEN
c         WRITE(NERR,'(44H SETSKM - POLAR PARAMETER LESS THAN ZERO, M=,
c     +                I10)') M
         IRES = -1
      END IF
      IF (IRES .EQ. -1) THEN
      CALL LOADCOMMON(dpx,RTAU,RKAPPA,ALFA,SRELPR,
     +                       ilx, SING,
     +                       ix, NPDE1,NC,MM,NERR,NNNPDE,NNNPTS,
     +                       icx, PDCODE)

      RETURN
      ENDIF
      CALL LOADCOMMON(dpx,RTAU,RKAPPA,ALFA,SRELPR,
     +                       ilx, SING,
     +                       ix, NPDE1,NC,MM,NERR,NNNPDE,NNNPTS,
     +                       icx, PDCODE)
C
C Initialize grid and PDE variables by appropriate calls.
C
      CALL YINIT (ithrndx,ikilflg,
     +            NPDE, NPTS, XL, XR, Y,
     +            dpx,ilx,ix,icx)
C
      PDCODE = 'SPSKLM'
      CALL LOADCOMMON(dpx,RTAU,RKAPPA,ALFA,SRELPR,
     +                       ilx, SING,
     +                       ix, NPDE1,NC,MM,NERR,NNNPDE,NNNPTS,
     +                       icx, PDCODE)


      RETURN
      END
      SUBROUTINE YINIT (ithrndx,ikilflg,
     +                  NPDE, NPTS, XL, XR, Y,
     + dpx,ilx,ix,icx)
      double precision dpx(4), dRTAU, dRKAPPA, dALFA, dSRELPR
      integer ilx, icx
      logical SING
      integer ix(6), NPDE1, NC,M, dNERR, dNNNPDE, dNNNPTS
      character*6 dPDCODE
      external UINIT

      INTEGER NPDE, NPTS
      DOUBLE PRECISION XL, XR
      DOUBLE PRECISION Y(NPDE+1,0:NPTS-1)
C
cQ    INTEGER NPDE1, NC, M
cQ    LOGICAL SING
cQ    COMMON /SPSKM/ NPDE1, NC, M, SING
cQ    SAVE   /SPSKM/
C
C
      INTEGER I
      DOUBLE PRECISION DX, XI
      CALL FETCHCOMMON(dpx,dRTAU,dRKAPPA,dALFA,dSRELPR,
     +                       ilx, SING,
     +                       ix, NPDE1,NC,M,dNERR,dNNNPDE,dNNNPTS,
     +                       icx, dPDCODE)

C
C Equidistant grid
      DX = (XR-XL)/(NC+1)
      DO 10 I = 0, NC+1
         XI = XL+I*DX
         Y(NPDE1,I) = XI
   10 CONTINUE
      CALL UINIT (ithrndx,ikilflg,NPDE, NPTS, Y)
      RETURN
      END
      SUBROUTINE SKMRES (ithrndx,ikilflg,
     +             NEQN, T, Y, YDOT, RES, IRES, RWK, NRWK,
     +           dpx,ilx,ix,icx)
      double precision dpx(4), dRTAU, dRKAPPA, dALFA, SRELPR
      integer ilx, icx
      logical SING
      integer ix(6), NPDE1, NC,M , NERR, dNNNPDE, dNNNPTS
      character*6 PDCODE

C
C-----------------------------------------------------------------------
C Purpose:
C -------
C Enveloping routine to compute the residual of the PDE and of the grid
C equations. SKMRES checks on node-crossing, partitions the workspace
C and calls CWRESU for the spatial discretization and the computation
C of the residual of the PDE in Lagrangian formulation and CWRESX for
C the spatial discretization and the residual computation of the grid
C equations.
C
C Parameters:
C ----------
      INTEGER NEQN, IRES, NRWK
      DOUBLE PRECISION T
      DOUBLE PRECISION Y(NEQN), YDOT(NEQN), RES(NEQN), RWK(NRWK)
C
C NEQN  Entry: the size of the DAE system generated when the PDE +
C       the grid equations are discretized.
C T     Entry: evaluation time.
C Y     Entry: array of length NEQN containing the DAE vector consisting
C       of the spatial mesh and the corresponding initial PDE solution
C       values at time T. This array is ordered as
C          PDE comp.  : Y((NPDE+1)*l + j) l=0,...,NPTS-1,
C                                         j=1,...,NPDE
C          grid points: Y((NPDE+1)*(l+1)) l=0,...,NPTS-1.
C RES   Exit: residual vector.
C       If IRES = -1 RES should contain only the part of the residual
C       dependent on the time-derivative, if IRES /= -1 RES should
C       contain the full residual  A.ydot - g.
C IRES  Entry: see above.
C       Exit: 2, if setup routine SETSKM has not been called.
C             3, if one of the DAE solutions in the vector Y is not
C                acceptable.
C RWK   working storage of length NRWK.
C NRWK  Entry: dimension of RWK. Should be >= NEQN + (6+NPDE)*NPDE.
C
C-----------------------------------------------------------------------
C
cQ    CHARACTER*6 PDCODE
cQ    COMMON /DISCHK/ PDCODE
C
cQ   INTEGER NPDE1, NC, M
cQ    LOGICAL SING
cQ    COMMON /SPSKM/ NPDE1, NC, M, SING
C
cQ    INTEGER NERR
cQ    DOUBLE PRECISION SRELPR
cQ    COMMON /MACHAA/ NERR
cQ    COMMON /MACHBB/ SRELPR
C
cQ    SAVE   /DISCHK/
cQ    SAVE   /SPSKM/
C     SAVE   /MACH/
C
      EXTERNAL CWRESU, CWRESX
C
C-----------------------------------------------------------------------
C
      INTEGER I, IW1, IW2, IW3, IW4, IW5, IW6, IW7, J, NPDE
      CALL FETCHCOMMON(dpx,dRTAU,dRKAPPA,dALFA,SRELPR,
     +                       ilx, SING,
     +                       ix, NPDE1,NC,M ,NERR,dNNNPDE,dNNNPTS,
     +                       icx, PDCODE)

      IF (PDCODE .NE. 'SPSKLM') THEN
c         WRITE(NERR,*) ' ERROR IN SKLMRES ROUTINE - THE SETUP ROUTINE'//
c     +                 ' SETSKM WAS NOT CALLED PRIOR TO SPRINT ENTRY'
         IRES = 2
         RETURN
      ENDIF

      NPDE = NPDE1-1

C Check on node-crossing
      DO 5 I = NPDE1, NEQN-NPDE1, NPDE1
         IF (Y(I) .GE. Y(I+NPDE1)) THEN
c            WRITE(NERR,'(30H SKMRES - NON-MONOTONOUS GRID,,
c     +                   22H VALUES OF GRID POINTS, I3,1H,,I3,
c     +                    4H ARE, E13.5,1H1,E13.5)')
c     +                   I/NPDE1, I/NPDE1+1, Y(I), Y(I+NPDE1)
            IRES = 3
         ENDIF
    5 CONTINUE

C Partition workspace
      IW1 =   1 + NEQN
      IW2 = IW1 + NPDE
      IW3 = IW2 + NPDE
      IW4 = IW3 + NPDE
      IW5 = IW4 + NPDE
      IW6 = IW5 + NPDE
      IW7 = IW6 + NPDE

C Calculate A.ydot and g for Lagrangian PDE
      CALL CWRESU (ithrndx,ikilflg,
     +             T, Y, YDOT, NPDE1-1, NC, M, SING,
     +             RWK(IW1), RWK(IW2), RWK(IW3), RWK(IW4),
     +             RWK(IW5), RWK(IW6), RWK(IW7),
     +             RES, RWK(1), IRES)
      CALL LOADCOMMON(dpx,dRTAU,dRKAPPA,dALFA,SRELPR,
     +                       ilx, SING,
     +                       ix, NPDE1,NC,M ,NERR,dNNNPDE,dNNNPTS,
     +                       icx, PDCODE)
      IF (IRES .GE. 3) RETURN

C Calculate A.ydot and g for grid equations
      CALL CWRESX (T, Y, YDOT, NPDE1, NC, RES, RWK(1), IRES,
     +             dpx,ilx,ix,icx)
      CALL LOADCOMMON(dpx,dRTAU,dRKAPPA,dALFA,SRELPR,
     +                       ilx, SING,
     +                       ix, NPDE1,NC,M ,NERR,dNNNPDE,dNNNPTS,
     +                       icx, PDCODE)
      IF (IRES .GE. 3) RETURN

      IF (IRES .NE. -1) THEN
C      Full residual needed; RES = A.ydot - g
         DO 10 J = 1, NEQN
            RES(J) = RES(J) - RWK(J)
   10    CONTINUE
      ENDIF

      RETURN
      END
      SUBROUTINE CWRESU (ithrndx,ikilflg,
     +                   T, Y, YDOT, NPDE, NC, M, SING,
     +                   UKSI, UXKSI, BETA, GAMMA, RC, QC, CC,
     +                   AYDOT, G, IRES)
C
C-----------------------------------------------------------------------
C Purpose:
C -------
C Compute PDE part of residual equations A.ydot - g.
C   Return A.ydot in AYDOT and g in G to satisfy both
C   SPRINT and DASSL.
C
C Method:
C ------
C The Lagrangian form of the PDE is:
C   NPDE                   .k   k .
C   sum  C   (x,t, u, u ) (u - u  x)  + Q (x,t, u, u )
C   k=1   j,k      -  -x        x        j      -  -x
C
C                                    -m   m
C                                =  x   (x  R (x,t, u, u ))
C                                            j      -  -x  x
C     where        1         NPDE T
C           u = ( u , ... , u    )   ,  j = 1,... , NPDE,
C           -
C         .k                                                         .
C     and u  is the total time-derivative of the k-th comp. of u and x
C     is the derivative wrt to time of x.
C
C This equation is semi-discretized by a lumped finite-element method
C   (udot and ux.xdot lumped).
C   Integration over the l-1_th interval and over the l_th interval
C   both give an expression for the flux in X . Eliminating this value
C                                            l
C   gives a difference equation for l=1,...,N:
C
C                                               .                     .
C fR  R (ksi ) - fR   R (ksi   ) = fS1  S (ksi ,U ) + fSl   S (ksi   ,U )
C   l  j    l      l-1 j    l-1       l  j    l -l       l-1 j    l-1 -l
C
C   with:
C
C          m-mu   mu
C fR = zeta    ksi        , mu = -1 if PDE singular otherwise mu = m
C   l      l      l
C
C            m+1   m+1
C fS1 = (zeta   - X   ) / (m+1)
C    l       l     l
C
C           m+1      m+1
C fSl   = (X   - zeta   ) / (m+1)
C    l-1    l        l-1
C
C         .     NPDE            .p        p     .
C S (ksi ,U ) = sum C  (ksi ) [ U (X ) - U (X ) X ] + Q (ksi )
C  j    k -l    p=1  jp    k        l     x  l   l     j    k
C
C R , j_th component of flux evaluated at quadrature point ksi,
C  j
C Q , j_th component of source term evaluated at quadrature point ksi,
C  j
C C  , element j,p of matrix multiplying u , evaluated at ksi.
C  jp                                     t
C
C Left boundary equation, if non-singular:
C                                               .
C BETA (x ,t) R (x ) = GAMMA (x ,t, U , U (x ))
C     j  L     j  L         j  L    -0  -x  L
C
C   with
C              m                       .       m
C R (x ) = (ksi R (ksi ) - fS1 S (ksi ,U )) / x
C  j  L        0 j    0       0 j    0 -0      L
C
C                         if singular:
C         .
C S (ksi ,U )/(m+1) - R (ksi )/ksi  = 0
C  j    0 -0           j    0     0
C
C Right boundary equation:
C                                                 .
C BETA (x ,t) R (x ) = GAMMA (x ,t, U   , U (x ))
C     j  R     j  R         j  R    -N+1  -x  R
C
C   with
C                                      .         m
C R (x ) = (fR  R (ksi ) + fSl S (ksi ,U   )) / x
C  j  R       N  j    N       N j    N -N+1      R
C
C
C Parameters:
C ----------
      INTEGER NPDE, NC, M, IRES
      LOGICAL SING
      DOUBLE PRECISION T
      DOUBLE PRECISION Y(NPDE+1,0:NC+1), YDOT(NPDE+1,0:NC+1),
     +     UKSI(NPDE), UXKSI(NPDE), BETA(NPDE), GAMMA(NPDE),
     +     RC(NPDE), QC(NPDE), CC(NPDE,NPDE),
     +     AYDOT(NPDE+1,0:NC+1), G(NPDE+1,0:NC+1)
C
C T      Entry: evaluation time
C Y      Entry: solution and grid at time T.
C        (Y(1:NPDE,L): U_l, Y(NPDE+1,L): X_l)
C YDOT   Entry: derivative of Y at T.
C NPDE   Entry: # PDEs.
C NC     Entry: # internal grid points.
C M      Entry: coordinate system indicator.
C SING   Entry: true, if PDE has a polar singularity (M>0, x_L=0).
C UKSI   workspace to hold the solution value at an evaluation point.
C UXKSI  workspace to hold the space derivatives at an evaluation point.
C BETA   workspace to hold the boundary function BETA.
C GAMMA  workspace to hold the boundary function GAMMA
C RC     workspace to hold the PDE function R.
C QC     workspace to hold the PDE function Q.
C CC     workspace to hold the PDE function C.
C AYDOT  Exit: A.ydot part of the residual.
C G      Exit: g part of the residual.
C IRES   Exit: 3 if some user function indicated that a solution value
C        is unphysical.
C
C Local variables:
C ---------------
      INTEGER MU
      DOUBLE PRECISION FSCL, FSC1, SCLMQ, SCL1MQ,
     +     DENOMI, KSI, KSIMU, ZETA, ZETAMU, PHIL, PHILX
C MU     if sing. then -1 else m.
C FSCL   fS1_l.
C FSC1   fSl_l+1.
C SCLMQ  S(ksi_l,udot_l)   - Q(ksi_l).
C SCL1MQ S(ksi_l,udot_l+1) - Q(ksi_l).
C DENOMI 1 / [ (X_l,X_l+1) int y**(-m) dy ]
C KSI    quadrature point for l_th interval
C KSIMU  ksi**mu
C ZETA   zeta_l ** (m+1); if sing. and l=0 then
C                         zeta = 0.0
C                         else   (X_l,X_l+1) int y dy * denomi
C ZETAMU zeta_l ** (m-mu)
C PHIL   'left' trial function for l_th interval in eval. point ksi
C        NB. phi_l+1 = 1 - phil
C PHILX  deriv. of phi_l wrt x in eval. point ksi
C        NB. phi_l+1_x = - phil_x
C
C
C
C -------------------------------------------------------------------
C
      INTEGER IP, J, L, NPDE1
      DOUBLE PRECISION DENPHI, RCJDOT, RCJG, UXL, UXL1, X0, X0M, XL,
     +     XL1, XN1M
      EXTERNAL SPDEF, BNDR

      NPDE1 = NPDE+1

      X0 = Y(NPDE1,0)
      IF (SING) THEN
         MU = -1
      ELSE
         MU = M
      ENDIF
C
C First interval, compute contribution to residual eq. in X_1 and
C   left boundary equation
C
      L = 0
         XL  = X0
         XL1 = Y(NPDE1,L+1)
         IF (.NOT. SING) THEN
            IF (M .EQ. 1) THEN
               DENOMI = 1/LOG(XL1/XL)
            ELSE
               DENOMI = (1-M)/(XL1**(1-M) - XL**(1-M))
            ENDIF
         ENDIF
         IF (SING) THEN
            KSI = 2/3. * (XL1**3-XL**3) / (XL1**2-XL**2)
            KSIMU = 1/KSI
         ELSE IF (M .EQ. 1) THEN
            KSI = (XL1-XL) * DENOMI
            KSIMU = KSI
         ELSE IF (M .EQ. 2) THEN
            KSI = LOG(XL1/XL) * DENOMI
            KSIMU = KSI*KSI
         ELSE
            KSI = (XL1**(2-M)-XL**(2-M)) / (2-M) * DENOMI
            IF (M .EQ. 0) THEN
               KSIMU = 1.0
            ELSE
               KSIMU = KSI**MU
            ENDIF
         ENDIF
         IF (SING) THEN
            ZETA = 0.0
            ZETAMU = ZETA
            DENPHI = 1/(XL1*XL1-XL*XL)
            PHIL = (XL1*XL1-KSI*KSI)*DENPHI
            PHILX = -2*KSI*DENPHI
         ELSE
            ZETA = 0.5*(XL1*XL1-XL*XL) * DENOMI
            ZETAMU = 1.0
            IF (M .EQ. 1) THEN
               PHIL = LOG(XL1/KSI) * DENOMI
               PHILX = -1/KSI * DENOMI
            ELSE IF (M .EQ. 0) THEN
               PHIL = (XL1 - KSI) * DENOMI
               PHILX = -DENOMI
            ELSE
               PHIL = (XL1**(1-M) - KSI**(1-M)) / (1-M) * DENOMI
               PHILX = -KSI**(-M) * DENOMI
            ENDIF
         ENDIF
         IF (M .EQ. 0) THEN
            X0M = 1.0
         ELSE
            X0M = X0**M
         ENDIF

C      Get left boundary function values
         DO 5 J = 1, NPDE
            UXKSI(J) = (Y(J,1)-Y(J,0)) / (XL1-XL)
    5    CONTINUE
         CALL BNDR (ithrndx, ikilflg,
     +              T, BETA, GAMMA, Y(1,0), UXKSI,
     +              NPDE, .TRUE., IRES)
         IF (IRES .EQ. 3) RETURN

C Compute U and Ux in evaluation point
         DO 10 J = 1, NPDE
            UKSI(J)  = Y(J,L)*PHIL  + Y(J,L+1)*(1-PHIL)
            UXKSI(J) = Y(J,L)*PHILX + Y(J,L+1)*(-PHILX)
   10    CONTINUE
C Get C, Q and R in evaluation point
         CALL SPDEF (ithrndx, ikilflg,
     +              T, KSI, NPDE, UKSI, UXKSI, CC, QC, RC, IRES)
         IF (IRES .EQ. 3) RETURN

         FSCL = (ZETA- XL**(M+1))/(M+1)
         FSC1 = (XL1**(M+1)-ZETA)/(M+1)
         DO 20 J = 1, NPDE
            SCLMQ  = 0.0
            SCL1MQ = 0.0
            DO 30 IP = 1, NPDE
               UXL1 = (Y(IP,L+2)-Y(IP,L  ))/(Y(NPDE1,L+2)-Y(NPDE1,L  ))
               SCLMQ  = SCLMQ  +
     +                  CC(J,IP)*(YDOT(IP,L  ))
               SCL1MQ = SCL1MQ +
     +                  CC(J,IP)*(YDOT(IP,L+1)-UXL1*YDOT(NPDE1,L+1))
   30       CONTINUE
C Store contribution from l_th interval to residual equation in X_l+1
            AYDOT(J,L+1) = FSC1 * SCL1MQ
            G    (J,L+1) = -ZETAMU*KSIMU*RC(J) - FSC1*QC(J)
C Compute boundary equations
            IF (SING) THEN
	       IF (BETA(J) .NE. 0) THEN
C               Bnd.eq. is contribution from 0_th interval to
C               difference eq. in x_L
                  AYDOT(J,0) = SCLMQ / (M+1)
                  G    (J,0) = RC(J)/KSI - QC(J)/(M+1)
	       ELSE
                  AYDOT(J,0) = 0.0
                  G    (J,0) = GAMMA(J)
	       ENDIF
            ELSE
C            Otherwise compute flux in x_L from contribution from 0_th
C            interval to difference equation in x_L, and substitute in
C            user's boundary equation.
               RCJDOT = -FSCL * SCLMQ / X0M
               RCJG   = (KSIMU*RC(J) - FSCL*QC(J)) / X0M
               AYDOT(J,0) = -BETA(J)*RCJDOT
               G    (J,0) = BETA(J)*RCJG - GAMMA(J)
            ENDIF
   20    CONTINUE

      DO 100 L = 1, NC-1
C
C Evaluate PDE functions in quadrature point in l_th interval.
C Add contribution from [X_l,X_l+1] to that of previous interval to
C get residual equation in X_l.
C Store contribution from l_th interval to residual equation in X_l+1.
C
         XL  = XL1
         XL1 = Y(NPDE1,L+1)
         IF (M .EQ. 1) THEN
            DENOMI = 1/LOG(XL1/XL)
         ELSE
            DENOMI = (1-M)/(XL1**(1-M) - XL**(1-M))
         ENDIF
         IF (SING) THEN
            KSI = 2/3. * (XL1**3-XL**3) / (XL1**2-XL**2)
            KSIMU = 1/KSI
         ELSE IF (M .EQ. 1) THEN
            KSI = (XL1-XL) * DENOMI
            KSIMU = KSI
         ELSE IF (M .EQ. 2) THEN
            KSI = LOG(XL1/XL) * DENOMI
            KSIMU = KSI*KSI
         ELSE
            KSI = (XL1**(2-M)-XL**(2-M)) / (2-M) * DENOMI
            IF (M .EQ. 0) THEN
               KSIMU = 1.0
            ELSE
               KSIMU = KSI**MU
            ENDIF
         ENDIF
         ZETA = 0.5*(XL1*XL1-XL*XL) * DENOMI
         IF (SING) THEN
            ZETAMU = ZETA
            DENPHI = 1/(XL1*XL1-XL*XL)
            PHIL = (XL1*XL1-KSI*KSI)*DENPHI
            PHILX = -2*KSI*DENPHI
         ELSE
            ZETAMU = 1.0
            IF (M .EQ. 1) THEN
               PHIL = LOG(XL1/KSI) * DENOMI
               PHILX = -1/KSI * DENOMI
            ELSE IF (M .EQ. 0) THEN
               PHIL = (XL1 - KSI) * DENOMI
               PHILX = -DENOMI
            ELSE
               PHIL = (XL1**(1-M) - KSI**(1-M)) / (1-M) * DENOMI
               PHILX = -KSI**(-M) * DENOMI
            ENDIF
         ENDIF

C Compute U and Ux in evaluation point
         DO 110 J = 1, NPDE
            UKSI(J)  = Y(J,L)*PHIL  + Y(J,L+1)*(1-PHIL)
            UXKSI(J) = Y(J,L)*PHILX + Y(J,L+1)*(-PHILX)
  110    CONTINUE
C Get C, Q and R in evaluation point
         CALL SPDEF (ithrndx, ikilflg,
     +              T, KSI, NPDE, UKSI, UXKSI, CC, QC, RC, IRES)
         IF (IRES .EQ. 3) RETURN

         FSCL = (ZETA- XL**(M+1))/(M+1)
         FSC1 = (XL1**(M+1)-ZETA)/(M+1)
         DO 120 J = 1, NPDE
            SCLMQ  = 0.0
            SCL1MQ = 0.0
            DO 130 IP = 1, NPDE
               UXL  = (Y(IP,L+1)-Y(IP,L-1))/(Y(NPDE1,L+1)-Y(NPDE1,L-1))
               UXL1 = (Y(IP,L+2)-Y(IP,L  ))/(Y(NPDE1,L+2)-Y(NPDE1,L  ))
               SCLMQ  = SCLMQ  +
     +                  CC(J,IP)*(YDOT(IP,L  )-UXL *YDOT(NPDE1,L  ))
               SCL1MQ = SCL1MQ +
     +                  CC(J,IP)*(YDOT(IP,L+1)-UXL1*YDOT(NPDE1,L+1))
  130       CONTINUE
C Add contribution over l_th interval to residual equation in X_l
            AYDOT(J,L) = AYDOT(J,L) + FSCL * SCLMQ
            G    (J,L) = G    (J,L) + ZETAMU*KSIMU*RC(J) - FSCL*QC(J)
C Store contribution from l_th interval to residual equation in X_l+1
            AYDOT(J,L+1) = FSC1 * SCL1MQ
            G    (J,L+1) = -ZETAMU*KSIMU*RC(J) - FSC1*QC(J)
  120    CONTINUE
  100 CONTINUE

      L = NC
C
C Add contribution over N_th interval to residual equation in X_N.
C Compute right boundary equation.
C
         XL  = XL1
         XL1 = Y(NPDE1,L+1)
         IF (M .EQ. 1) THEN
            DENOMI = 1/LOG(XL1/XL)
         ELSE
            DENOMI = (1-M)/(XL1**(1-M) - XL**(1-M))
         ENDIF
         IF (SING) THEN
            KSI = 2/3. * (XL1**3-XL**3) / (XL1**2-XL**2)
            KSIMU = 1/KSI
         ELSE IF (M .EQ. 1) THEN
            KSI = (XL1-XL) * DENOMI
            KSIMU = KSI
         ELSE IF (M .EQ. 2) THEN
            KSI = LOG(XL1/XL) * DENOMI
            KSIMU = KSI*KSI
         ELSE
            KSI = (XL1**(2-M)-XL**(2-M)) / (2-M) * DENOMI
            IF (M .EQ. 0) THEN
               KSIMU = 1.0
            ELSE
               KSIMU = KSI**MU
            ENDIF
         ENDIF
         ZETA = 0.5*(XL1*XL1-XL*XL) * DENOMI
         IF (SING) THEN
            ZETAMU = ZETA
            DENPHI = 1/(XL1*XL1-XL*XL)
            PHIL = (XL1*XL1-KSI*KSI)*DENPHI
            PHILX = -2*KSI*DENPHI
         ELSE
            ZETAMU = 1.0
            IF (M .EQ. 1) THEN
               PHIL = LOG(XL1/KSI) * DENOMI
               PHILX = -1/KSI * DENOMI
            ELSE IF (M .EQ. 0) THEN
               PHIL = (XL1 - KSI) * DENOMI
               PHILX = -DENOMI
            ELSE
               PHIL = (XL1**(1-M) - KSI**(1-M)) / (1-M) * DENOMI
               PHILX = -KSI**(-M) * DENOMI
            ENDIF
         ENDIF
         IF (M .EQ. 0) THEN
            XN1M = 1.0
         ELSE
            XN1M = XL1**M
         ENDIF

C Get right boundary function values
         DO 205 J = 1, NPDE
            UXKSI(J) = (Y(J,NC+1)-Y(J,NC)) / (XL1-XL)
  205    CONTINUE
         CALL BNDR (ithrndx, ikilflg,
     +              T, BETA, GAMMA, Y(1,NC+1), UXKSI,
     +              NPDE, .FALSE., IRES)
         IF (IRES .EQ. 3) RETURN

C Compute U and Ux in evaluation point
         DO 210 J = 1, NPDE
            UKSI(J)  = Y(J,L)*PHIL  + Y(J,L+1)*(1-PHIL)
            UXKSI(J) = Y(J,L)*PHILX + Y(J,L+1)*(-PHILX)
  210    CONTINUE
C Get C, Q and R in evaluation point
         CALL SPDEF (ithrndx, ikilflg,
     +              T, KSI, NPDE, UKSI, UXKSI, CC, QC, RC, IRES)
         IF (IRES .EQ. 3) RETURN

         FSCL = (ZETA- XL**(M+1))/(M+1)
         FSC1 = (XL1**(M+1)-ZETA)/(M+1)
         DO 220 J = 1, NPDE
            SCLMQ  = 0.0
            SCL1MQ = 0.0
            DO 230 IP = 1, NPDE
               UXL  = (Y(IP,L+1)-Y(IP,L-1))/(Y(NPDE1,L+1)-Y(NPDE1,L-1))
               SCLMQ  = SCLMQ  +
     +                  CC(J,IP)*(YDOT(IP,L  )-UXL *YDOT(NPDE1,L  ))
               SCL1MQ = SCL1MQ +
     +                  CC(J,IP)*(YDOT(IP,L+1))
  230       CONTINUE
C Add contribution over N_th interval to residual equation in X_N
            AYDOT(J,L) = AYDOT(J,L) + FSCL * SCLMQ
            G    (J,L) = G    (J,L) + ZETAMU*KSIMU*RC(J) - FSCL*QC(J)
C Compute flux in x_R and substitute in user's boundary condition
            RCJDOT = FSC1 * SCL1MQ / XN1M
            RCJG   = (ZETAMU*KSIMU*RC(J) + FSC1*QC(J)) / XN1M
            AYDOT(J,NC+1) = -BETA(J)*RCJDOT
            G    (J,NC+1) = BETA(J)*RCJG - GAMMA(J)
  220    CONTINUE

      RETURN
      END
      SUBROUTINE CWRESX (T, Y, YDOT, NPDE1, NC, AYDOT, G, IRES,
     +           dpx,ilx,ix,icx)
      double precision dpx(4), RTAU, RKAPPA, ALFA, dSRELPR
      integer ilx, icx
      logical dSING
      integer ix(6), dNPDE1, dNC,dMM, dNERR, dNNNPDE, dNNNPTS
      character*6 dPDCODE

C
C-----------------------------------------------------------------------
C Purpose:
C -------
C Define grid part of DAE system in general form, i.e. A.ydot and g
C separated to satisfy both SPRINT and DASSL.
C The equations for the moving grid are
C              .                  .
C   nt   + tau.nt        nt + tau.nt
C     i-1        i-1       i        i
C   ----------------  -  ------------  =  0       1 <= i <= N,
C         M                   M
C          i-1                 i
C
C with nt  = n - fac.(n   - 2.n + n   );  fac = rkappa.(rkappa+1)  and
C        i    i        i+1     i   i-1
C
C       n  = 1 / (X   - X ),   n   = n , n    = n .
C        i         i+1   i      -1    0    N+1   N
C
C For simplicity reasons x  and x  are also part of the DAE vector; since
C                         L      R
C the boundaries are fixed we have used as ODEs for these variables
C   .    .
C   X  = X    = 0.
C    0    N+1
C
C Parameters:
C ----------
      INTEGER NPDE1, NC, IRES
      DOUBLE PRECISION T
      DOUBLE PRECISION Y(NPDE1,0:NC+1), YDOT(NPDE1,0:NC+1),
     +     AYDOT(NPDE1,0:NC+1), G(NPDE1,0:NC+1)
C
C T      Entry: evaluation time
C Y      Entry: solution and grid at time T.
C        (Y(1:NPDE,L): U_l, Y(NPDE+1,L): X_l)
C YDOT   Entry: derivative of Y at T.
C NPDE1  Entry: # PDEs + 1.
C NC     Entry: # internal grid points.
C AYDOT  Exit: A.ydot part of the residual.
C G      Exit: g part of the residual.
C IRES   Exit:  not used.
C
C-----------------------------------------------------------------------
C
cQ    DOUBLE PRECISION RTAU, RKAPPA, ALFA
cQ    COMMON /METPAR/ RTAU, RKAPPA, ALFA
cQ    SAVE   /METPAR/
C
C-----------------------------------------------------------------------
C
      INTEGER I, NPDE
      DOUBLE PRECISION A0, AM, FAC, G0, GM, NIM1, NI, NIP1, NTI, NTDI
      CALL FETCHCOMMON(dpx,RTAU,RKAPPA,ALFA,dSRELPR,
     +                       ilx, dSING,
     +                       ix, dNPDE1,dNC,dMM,dNERR,dNNNPDE,dNNNPTS,
     +                       icx, dPDCODE)

C
      NPDE = NPDE1-1
C
C ccc Define smoothing factor
      FAC = RKAPPA*(RKAPPA+1)
C
C ccc Compute monitor values; store M(I) temp. in G(NPDE1,I), I=0, NC
      CALL XMNTR (Y, G, NPDE, NC,
     +            dpx, ilx, ix, icx)
C
C ccc Compute A.xdot and g for grid equations.
C   Interior equations:
C     A.xdot (I) = RTAU/M(I-1).NTDOT(I-1) - RTAU/M(I).NTDOT(I)
C     g(I)       = NT(I)/M(I) - NT(I-1)/M(I-1)
C     NT(I) = N(I) - FAC.(N(I-1)-2.N(I)+N(I+1))
C     N (I) = 1 / (X(I+1)-X(I))
      I = 0
         NI   = 1/(Y(NPDE1,I+1)-Y(NPDE1,I  ))
         NIM1 = NI
         NIP1 = 1/(Y(NPDE1,I+2)-Y(NPDE1,I+1))

         NTI  = NI - FAC*(NIM1-2*NI+NIP1)
         NTDI = -
     +          (1+  FAC)*NI  *NI  *(YDOT(NPDE1,I+1)-YDOT(NPDE1,I  )) +
     +               FAC *NIP1*NIP1*(YDOT(NPDE1,I+2)-YDOT(NPDE1,I+1))

         A0 = RTAU / G(NPDE1,I) * NTDI
         G0 = NTI / G(NPDE1,I)

      DO 10 I = 1, NC-1
         NIM1 = NI
         NI   = NIP1
         AM   = A0
         GM   = G0

         NIP1 = 1/(Y(NPDE1,I+2)-Y(NPDE1,I+1))

         NTI  = NI - FAC*(NIM1-2*NI+NIP1)
         NTDI =      FAC *NIM1*NIM1*(YDOT(NPDE1,I  )-YDOT(NPDE1,I-1)) -
     +          (1+2*FAC)*NI  *NI  *(YDOT(NPDE1,I+1)-YDOT(NPDE1,I  )) +
     +               FAC *NIP1*NIP1*(YDOT(NPDE1,I+2)-YDOT(NPDE1,I+1))

         A0 = RTAU / G(NPDE1,I) * NTDI
         G0 = NTI / G(NPDE1,I)

         AYDOT(NPDE1,I) = AM - A0
         G    (NPDE1,I) = G0 - GM
   10 CONTINUE
      I = NC
         NIM1 = NI
         NI   = NIP1
         AM   = A0
         GM   = G0

         NIP1 = NI

         NTI  = NI - FAC*(NIM1-2*NI+NIP1)
         NTDI =      FAC *NIM1*NIM1*(YDOT(NPDE1,I  )-YDOT(NPDE1,I-1)) -
     +          (1+  FAC)*NI  *NI  *(YDOT(NPDE1,I+1)-YDOT(NPDE1,I  ))

         A0 = RTAU / G(NPDE1,I) * NTDI
         G0 = NTI / G(NPDE1,I)

         AYDOT(NPDE1,I) = AM - A0
         G    (NPDE1,I) = G0 - GM

C   Boundary equations grid.
C      Fixed endpoints, xdot=0
      I=0
         AYDOT(NPDE1,I) = YDOT(NPDE1,I)
         G(NPDE1,I) = 0.0
      I=NC+1
         AYDOT(NPDE1,I) = YDOT(NPDE1,I)
         G(NPDE1,I) = 0.0
C
      RETURN
      END
      SUBROUTINE XMNTR (Y, G, NPDE, N,
     +           dpx,ilx,ix,icx)
      double precision dpx(4), RTAU, RKAPPA, ALFA, dSRELPR
      integer ilx, icx
      logical dSING
      integer ix(6), dNPDE1, dNC,dMM, dNERR, dNNNPDE, dNNNPTS
      character*6 dPDCODE

      INTEGER NPDE, N
      DOUBLE PRECISION Y(NPDE+1,0:N+1), G(NPDE+1,0:N+1)
C
C-----------------------------------------------------------------------
C Purpose:
C -------
C Compute monitor for grid equation,
C   M_i = M(x(i+1/2)) = sqrt(alfa + !!ux!!**2)
C
C Exit:
C   G(NPDE+1,i) = M(i)
C
C-----------------------------------------------------------------------
C
cQ    DOUBLE PRECISION RTAU, RKAPPA, ALFA
cQ    COMMON /METPAR/ RTAU, RKAPPA, ALFA
cQ    SAVE   /METPAR/
C
C-----------------------------------------------------------------------
C
      INTEGER I, K, NPDE1
      DOUBLE PRECISION DU, DX, SUX2
C
      CALL FETCHCOMMON(dpx,RTAU,RKAPPA,ALFA,dSRELPR,
     +                       ilx, dSING,
     +                       ix, dNPDE1,dNC,dMM,dNERR,dNNNPDE,dNNNPTS,
     +                       icx, dPDCODE)
      NPDE1 = NPDE+1

      DO 10 I = 0, N
         SUX2 = 0.0
         DO 20 K = 1, NPDE
            DU = Y(K,I+1)-Y(K,I)
            SUX2 = SUX2 + DU*DU
   20    CONTINUE
         DX = Y(NPDE1,I+1)-Y(NPDE1,I)
         SUX2 = SUX2 / (DX*DX)
         G(NPDE1,I) = SQRT(ALFA + SUX2/NPDE)
   10 CONTINUE

      RETURN
      END
C
C#######################################################################
C
C MACHAR : MACHAR routine from W.J. Cody
C          (available from Netlib: send machar from elefunt)
C
C#######################################################################
C
      SUBROUTINE MACHAR(IBETA,IT,IRND,NGRD,MACHEP,NEGEP,IEXP,MINEXP,
     1                   MAXEXP,EPS,EPSNEG,XMIN,XMAX)
C-----------------------------------------------------------------------
C  This Fortran 77 subroutine is intended to determine the parameters
C   of the floating-point arithmetic system specified below.  The
C   determination of the first three uses an extension of an algorithm
C   due to M. Malcolm, CACM 15 (1972), pp. 949-951, incorporating some,
C   but not all, of the improvements suggested by M. Gentleman and S.
C   Marovich, CACM 17 (1974), pp. 276-277.  An earlier version of this
C   program was published in the book Software Manual for the
C   Elementary Functions by W. J. Cody and W. Waite, Prentice-Hall,
C   Englewood Cliffs, NJ, 1980.  The present version is documented in
C   W. J. Cody, "MACHAR: A subroutine to dynamically determine machine
C   parameters," TOMS 14, December, 1988.
C
C  The program as given here must be modified before compiling.  If
C   a single (double) precision version is desired, change all
C   occurrences of CS (CD) in columns 1 and 2 to blanks.
C
C  Parameter values reported are as follows:
C
C       IBETA   - the radix for the floating-point representation
C       IT      - the number of base IBETA digits in the floating-point
C                 significand
C       IRND    - 0 if floating-point addition chops
C                 1 if floating-point addition rounds, but not in the
C                   IEEE style
C                 2 if floating-point addition rounds in the IEEE style
C                 3 if floating-point addition chops, and there is
C                   partial underflow
C                 4 if floating-point addition rounds, but not in the
C                   IEEE style, and there is partial underflow
C                 5 if floating-point addition rounds in the IEEE style,
C                   and there is partial underflow
C       NGRD    - the number of guard digits for multiplication with
C                 truncating arithmetic.  It is
C                 0 if floating-point arithmetic rounds, or if it
C                   truncates and only  IT  base  IBETA digits
C                   participate in the post-normalization shift of the
C                   floating-point significand in multiplication;
C                 1 if floating-point arithmetic truncates and more
C                   than  IT  base  IBETA  digits participate in the
C                   post-normalization shift of the floating-point
C                   significand in multiplication.
C       MACHEP  - the largest negative integer such that
C                 1.0+FLOAT(IBETA)**MACHEP .NE. 1.0, except that
C                 MACHEP is bounded below by  -(IT+3)
C       NEGEPS  - the largest negative integer such that
C                 1.0-FLOAT(IBETA)**NEGEPS .NE. 1.0, except that
C                 NEGEPS is bounded below by  -(IT+3)
C       IEXP    - the number of bits (decimal places if IBETA = 10)
C                 reserved for the representation of the exponent
C                 (including the bias or sign) of a floating-point
C                 number
C       MINEXP  - the largest in magnitude negative integer such that
C                 FLOAT(IBETA)**MINEXP is positive and normalized
C       MAXEXP  - the smallest positive power of  BETA  that overflows
C       EPS     - the smallest positive floating-point number such
C                 that  1.0+EPS .NE. 1.0. In particular, if either
C                 IBETA = 2  or  IRND = 0, EPS = FLOAT(IBETA)**MACHEP.
C                 Otherwise,  EPS = (FLOAT(IBETA)**MACHEP)/2
C       EPSNEG  - A small positive floating-point number such that
C                 1.0-EPSNEG .NE. 1.0. In particular, if IBETA = 2
C                 or  IRND = 0, EPSNEG = FLOAT(IBETA)**NEGEPS.
C                 Otherwise,  EPSNEG = (IBETA**NEGEPS)/2.  Because
C                 NEGEPS is bounded below by -(IT+3), EPSNEG may not
C                 be the smallest number that can alter 1.0 by
C                 subtraction.
C       XMIN    - the smallest non-vanishing normalized floating-point
C                 power of the radix, i.e.,  XMIN = FLOAT(IBETA)**MINEXP
C       XMAX    - the largest finite floating-point number.  In
C                 particular  XMAX = (1.0-EPSNEG)*FLOAT(IBETA)**MAXEXP
C                 Note - on some machines  XMAX  will be only the
C                 second, or perhaps third, largest number, being
C                 too small by 1 or 2 units in the last digit of
C                 the significand.
C
C     Latest revision - December 4, 1987
C
C     Author - W. J. Cody
C              Argonne National Laboratory
C
C-----------------------------------------------------------------------
      INTEGER I,IBETA,IEXP,IRND,IT,ITEMP,IZ,J,K,MACHEP,MAXEXP,
     1        MINEXP,MX,NEGEP,NGRD,NXRES
CS    REAL
      DOUBLE PRECISION
     1   A,B,BETA,BETAIN,BETAH,CONV,EPS,EPSNEG,ONE,T,TEMP,TEMPA,
     2   TEMP1,TWO,XMAX,XMIN,Y,Z,ZERO
C-----------------------------------------------------------------------
CS    CONV(I) = REAL(I)
      CONV(I) = DBLE(I)
      ONE = CONV(1)
      TWO = ONE + ONE
      ZERO = ONE - ONE
C-----------------------------------------------------------------------
C  Determine IBETA, BETA ala Malcolm.
C-----------------------------------------------------------------------
      A = ONE
   10 A = A + A
         TEMP = A+ONE
         TEMP1 = TEMP-A
         IF (TEMP1-ONE .EQ. ZERO) GO TO 10
      B = ONE
   20 B = B + B
         TEMP = A+B
         ITEMP = INT(TEMP-A)
         IF (ITEMP .EQ. 0) GO TO 20
      IBETA = ITEMP
      BETA = CONV(IBETA)
C-----------------------------------------------------------------------
C  Determine IT, IRND.
C-----------------------------------------------------------------------
      IT = 0
      B = ONE
  100 IT = IT + 1
         B = B * BETA
         TEMP = B+ONE
         TEMP1 = TEMP-B
         IF (TEMP1-ONE .EQ. ZERO) GO TO 100
      IRND = 0
      BETAH = BETA / TWO
      TEMP = A+BETAH
      IF (TEMP-A .NE. ZERO) IRND = 1
      TEMPA = A + BETA
      TEMP = TEMPA+BETAH
      IF ((IRND .EQ. 0) .AND. (TEMP-TEMPA .NE. ZERO)) IRND = 2
C-----------------------------------------------------------------------
C  Determine NEGEP, EPSNEG.
C-----------------------------------------------------------------------
      NEGEP = IT + 3
      BETAIN = ONE / BETA
      A = ONE
      DO 200 I = 1, NEGEP
         A = A * BETAIN
  200 CONTINUE
      B = A
  210 TEMP = ONE-A
         IF (TEMP-ONE .NE. ZERO) GO TO 220
         A = A * BETA
         NEGEP = NEGEP - 1
      GO TO 210
  220 NEGEP = -NEGEP
      EPSNEG = A
C-----------------------------------------------------------------------
C  Determine MACHEP, EPS.
C-----------------------------------------------------------------------
      MACHEP = -IT - 3
      A = B
  300 TEMP = ONE+A
         IF (TEMP-ONE .NE. ZERO) GO TO 320
         A = A * BETA
         MACHEP = MACHEP + 1
      GO TO 300
  320 EPS = A
C-----------------------------------------------------------------------
C  Determine NGRD.
C-----------------------------------------------------------------------
      NGRD = 0
      TEMP = ONE+EPS
      IF ((IRND .EQ. 0) .AND. (TEMP*ONE-ONE .NE. ZERO)) NGRD = 1
C-----------------------------------------------------------------------
C  Determine IEXP, MINEXP, XMIN.
C
C  Loop to determine largest I and K = 2**I such that
C         (1/BETA) ** (2**(I))
C  does not underflow.
C  Exit from loop is signaled by an underflow.
C-----------------------------------------------------------------------
      I = 0
      K = 1
      Z = BETAIN
      T = ONE + EPS
      NXRES = 0
  400 Y = Z
         Z = Y * Y
C-----------------------------------------------------------------------
C  Check for underflow here.
C-----------------------------------------------------------------------
         A = Z * ONE
         TEMP = Z * T
         IF ((A+A .EQ. ZERO) .OR. (ABS(Z) .GE. Y)) GO TO 410
         TEMP1 = TEMP * BETAIN
         IF (TEMP1*BETA .EQ. Z) GO TO 410
         I = I + 1
         K = K + K
      GO TO 400
  410 IF (IBETA .EQ. 10) GO TO 420
      IEXP = I + 1
      MX = K + K
      GO TO 450
C-----------------------------------------------------------------------
C  This segment is for decimal machines only.
C-----------------------------------------------------------------------
  420 IEXP = 2
      IZ = IBETA
  430 IF (K .LT. IZ) GO TO 440
         IZ = IZ * IBETA
         IEXP = IEXP + 1
      GO TO 430
  440 MX = IZ + IZ - 1
C-----------------------------------------------------------------------
C  Loop to determine MINEXP, XMIN.
C  Exit from loop is signaled by an underflow.
C-----------------------------------------------------------------------
  450 XMIN = Y
         Y = Y * BETAIN
C-----------------------------------------------------------------------
C  Check for underflow here.
C-----------------------------------------------------------------------
         A = Y * ONE
         TEMP = Y * T
         IF (((A+A) .EQ. ZERO) .OR. (ABS(Y) .GE. XMIN)) GO TO 460
         K = K + 1
         TEMP1 = TEMP * BETAIN
         IF ((TEMP1*BETA .NE. Y) .OR. (TEMP .EQ. Y)) THEN
               GO TO 450
            ELSE
               NXRES = 3
               XMIN = Y
         END IF
  460 MINEXP = -K
C-----------------------------------------------------------------------
C  Determine MAXEXP, XMAX.
C-----------------------------------------------------------------------
      IF ((MX .GT. K+K-3) .OR. (IBETA .EQ. 10)) GO TO 500
      MX = MX + MX
      IEXP = IEXP + 1
  500 MAXEXP = MX + MINEXP
C-----------------------------------------------------------------
C  Adjust IRND to reflect partial underflow.
C-----------------------------------------------------------------
      IRND = IRND + NXRES
C-----------------------------------------------------------------
C  Adjust for IEEE-style machines.
C-----------------------------------------------------------------
      IF (IRND .GE. 2) MAXEXP = MAXEXP - 2
C-----------------------------------------------------------------
C  Adjust for machines with implicit leading bit in binary
C  significand, and machines with radix point at extreme
C  right of significand.
C-----------------------------------------------------------------
      I = MAXEXP + MINEXP
      IF ((IBETA .EQ. 2) .AND. (I .EQ. 0)) MAXEXP = MAXEXP - 1
      IF (I .GT. 20) MAXEXP = MAXEXP - 1
      IF (A .NE. Y) MAXEXP = MAXEXP - 2
      XMAX = ONE - EPSNEG
      IF (XMAX*ONE .NE. XMAX) XMAX = ONE - BETA * EPSNEG
      XMAX = XMAX / (BETA * BETA * BETA * XMIN)
      I = MAXEXP + MINEXP + 3
      IF (I .LE. 0) GO TO 520
      DO 510 J = 1, I
          IF (IBETA .EQ. 2) XMAX = XMAX + XMAX
          IF (IBETA .NE. 2) XMAX = XMAX * BETA
  510 CONTINUE
  520 RETURN
C---------- LAST CARD OF MACHAR ----------
      END

C==================================================================

      SUBROUTINE RESID  (ithrndx,ikilflg,
     +           T, Y, YPRIME, DELTA, IRES, RWK, IPAR,
     +           dpx,ilx,ix,icx)
      double precision dpx(4), dRTAU, dRKAPPA, dALFA, dSRELPR
      integer ilx, icx
      logical  dSING
      integer ix(6), dNPDE1, dNC,dMM, dNERR, NNNPDE, NNNPTS
      character*6 dPDCODE

      INTEGER IRES
      INTEGER IPAR(*)
      DOUBLE PRECISION T
      DOUBLE PRECISION Y(*), YPRIME(*), DELTA(*), RWK(*)
C
C Determine DAE system for DASSL
C   residual DELTA = A.YPRIME - G
C
C Entry:
C   T     : Current time
C   Y     : Current grid + solution
C   YPRIME: Time derivative of Y
C Exit:
C   DELTA : A.YPRIME - G
C   IRES  : -1, if user thinks solution is illegal or ico node crossing
C   IRES  : -23, ikilflg=1, terminate routines
C ---------------------------------------------------------------------
C
cQ    INTEGER NNNPDE, NNNPTS
cQ    COMMON /forRESID/ NNNPDE, NNNPTS
cQ    SAVE /forRESID/
C
C ---------------------------------------------------------------------
C
      INTEGER NEQ, NRWK
      IF(ikilflg.EQ.1) THEN
          IRES=-23
          RETURN
      ENDIF
      CALL FETCHCOMMON(dpx,dRTAU,dRKAPPA,dALFA,dSRELPR,
     +                       ilx, dSING,
     +                       ix, dNPDE1,dNC,dMM,dNERR,NNNPDE,NNNPTS,
     +                       icx, dPDCODE)

C
      NEQ  = NNNPTS*(NNNPDE+1)
      NRWK = NEQ + (6+NNNPDE)*NNNPDE
C
C ccc Call SKMRES with IRES=0 to compute total residual
      IRES = 0
      CALL SKMRES (ithrndx,ikilflg,
     +             NEQ, T, Y, YPRIME, DELTA, IRES, RWK, NRWK,
     +             dpx,ilx,ix,icx)
      if(ikilflg.eq.1) THEN
          IRES=-23
          RETURN
      ENDIF
      IF (IRES .EQ. 2) THEN
         IRES = -2
         RETURN
      ELSE IF (IRES .EQ. 3) THEN
         IRES = -1
         RETURN
      ENDIF
C
      RETURN
      END
